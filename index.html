<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 元信息 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小说转 KAG 脚本 (两步式 + 通知 + 保存)</title>
    <!-- 页面样式 -->
    <style>
        /* 基本样式 */
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 950px; margin: 20px auto; background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        label { display: block; margin-top: 15px; margin-bottom: 5px; font-weight: bold; color: #555; }
        input[type="text"], input[type="password"], input[type="number"], textarea { width: 100%; padding: 10px; margin-top: 5px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        textarea { min-height: 120px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; vertical-align: top; line-height: 1.5; background-color: #fff; resize: vertical; }
        .textarea-small { min-height: 60px; }
        #structuredNovelText { background-color: #e8f4ff; } /* 格式化文本区域背景色 */
        #outputKs { background-color: #f0f0f0; min-height: 200px; color: #444; } /* KAG 输出区域背景色 */
        button { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px; margin-right: 10px; transition: background-color 0.2s ease; }
        button.secondary { background-color: #6c757d; } /* 次要按钮颜色 */
        button:hover { background-color: #0056b3; }
        button.secondary:hover { background-color: #5a6268; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.7; } /* 禁用按钮样式 */
        .status-indicator { margin-left: 10px; font-style: italic; font-size: 0.9em; color: #669; min-height: 1.2em; display: inline-block;} /* 状态指示器 */
        #param-status { font-size: 0.85em; color: green; margin-top: 5px; min-height: 1em;} /* 参数保存/加载状态 */
        .error { color: #d9534f; font-weight: bold; } /* 错误信息样式 */
        .config-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 15px; } /* 网格布局 */
        .config-item { min-width: 0; }
        fieldset { margin-bottom: 25px; border: 1px solid #ddd; padding: 20px; border-radius: 5px; background-color: #fafafa;} /* 配置区域边框 */
        legend { font-weight: bold; padding: 0 10px; color: #337ab7; font-size: 1.1em;} /* 配置区域标题 */
        .step-container { margin-top: 25px; padding-top: 20px; border-top: 1px dashed #ccc;} /* 步骤分隔线 */
        h1 { text-align: center; color: #337ab7; margin-bottom: 20px;} /* 主标题 */
        p { color: #666; font-size: 0.95em; } /* 普通段落 */
        .warning { color:#d9534f; font-weight:bold; border: 1px solid #d9534f; padding: 10px; border-radius: 4px; background-color: #fcf8e3;} /* 警告信息框 */
        .sound-path-label { font-size: 0.9em; color: #777; font-weight: normal; margin-top: 0; } /* 声音路径标签 */
    </style>
</head>
<body>
    <!-- 主容器 -->
    <div class="container">
        <!-- 标题和说明 -->
        <h1>小说章节转 KAG (.ks) 脚本 (两步式 + 通知 + 保存)</h1>
        <p>说明：配置 API，粘贴原文。步骤一转换格式（结果可保存为 TXT），步骤二转 KAG。可保存/加载参数。完成后会有系统通知和声音提示（需配置服务器可访问的声音文件路径）。</p>
        <p class="warning">警告：API Key 和声音文件路径会保存在服务器端的 `config.json` 文件中，请确保服务器文件安全。</p>

        <!-- 表单 -->
        <form id="conversionForm">
            <!-- API 配置 -->
            <fieldset>
                <legend>API 配置</legend>
                 <div class="config-grid">
                    <div class="config-item"> <label for="apiKey">LLM API Key:</label> <input type="password" id="apiKey" name="apiKey" required> </div>
                    <div class="config-item"> <label for="apiEndpoint">LLM API Base URL:</label> <input type="text" id="apiEndpoint" name="apiEndpoint" placeholder="例如: https://generativelanguage.googleapis.com" required> </div>
                    <div class="config-item"> <label for="modelName">LLM 模型名称:</label> <input type="text" id="modelName" name="modelName" placeholder="例如: gemini-1.5-flash-latest" required> </div>
                </div>
             </fieldset>

             <!-- 生成与通知参数 -->
             <fieldset>
                 <legend>生成与通知参数</legend>
                 <div class="config-grid">
                    <div class="config-item"> <label for="temperature">Temperature:</label> <input type="number" id="temperature" name="temperature" min="0" max="2" step="0.1" placeholder="例如: 0.6 (默认)"> </div>
                    <div class="config-item"> <label for="maxOutputTokens">Max Output Tokens:</label> <input type="number" id="maxOutputTokens" name="maxOutputTokens" min="1" step="1" placeholder="例如: 8192 (默认)"> </div>
                 </div>
                 {/* 声音文件路径输入 */}
                 <div class="config-grid">
                     <div class="config-item">
                         <label for="successSoundPath">成功提示音路径:</label>
                         <input type="text" id="successSoundPath" name="successSoundPath" placeholder="例如: C:/sounds/success.wav 或 /home/user/sounds/ok.mp3">
                         <label class="sound-path-label">输入服务器可访问的完整文件路径</label>
                     </div>
                     <div class="config-item">
                         <label for="failureSoundPath">失败提示音路径:</label>
                         <input type="text" id="failureSoundPath" name="failureSoundPath" placeholder="例如: C:/sounds/fail.wav 或 /home/user/sounds/error.ogg">
                          <label class="sound-path-label">输入服务器可访问的完整文件路径</label>
                     </div>
                 </div>
                 {/* 参数保存/加载按钮 */}
                 <div>
                     <button type="button" id="saveParamsButton" class="secondary">保存参数到服务器</button>
                     <button type="button" id="loadParamsButton" class="secondary">从服务器加载参数</button>
                     <span id="param-status"></span> {/* 参数操作状态显示区域 */}
                 </div>
             </fieldset>

            <!-- 输入与输出 -->
            <fieldset>
                <legend>输入与输出</legend>
                {/* 步骤一：输入区域 */}
                <label for="preNovelText">前置指令 (可选, 用于步骤一):</label>
                <textarea id="preNovelText" name="preNovelText" class="textarea-small" placeholder="例如：请仔细分析以下小说..."></textarea>
                <label for="novelText">原始小说原文:</label>
                <textarea id="novelText" name="novelText" required placeholder="在此粘贴需要处理的原始小说原文..."></textarea>
                <label for="postNovelText">后置指令 (可选, 用于步骤一):</label>
                <textarea id="postNovelText" name="postNovelText" class="textarea-small" placeholder="例如：确保标记完整。"></textarea>
                <button type="button" id="preprocessButton">第一步：转换小说格式</button>
                <span id="step1Status" class="status-indicator"></span> {/* 步骤一状态指示器 */}

                {/* 步骤一结果 和 步骤二输入区域 */}
                <div class="step-container">
                    <label for="structuredNovelText">格式化后的小说文本:</label>
                    <textarea id="structuredNovelText" name="structuredNovelText" placeholder="步骤一的结果将显示在这里，您可以编辑或直接粘贴符合格式的文本..." style="background-color: #f0f8ff;"></textarea>
                    {/* 新增：保存按钮，初始禁用 */}
                    <button type="button" id="savePreprocessedButton" class="secondary" disabled>保存为 TXT</button>
                    {/* 步骤二按钮，初始根据文本框内容决定是否禁用 */}
                    <button type="button" id="convertToKagButton" disabled>第二步：格式转 KAG</button>
                     <span id="step2Status" class="status-indicator"></span> {/* 步骤二状态指示器 */}
                </div>

                 {/* 步骤二结果区域 */}
                 <div class="step-container">
                    <label for="outputKs">生成的 KAG 脚本 (.ks):</label>
                    <textarea id="outputKs" readonly placeholder="步骤二 KAG 脚本结果将逐步显示在这里..."></textarea>
                 </div>
            </fieldset>
        </form>
    </div>

    <script>
        // --- 获取页面元素 (新增/修改的元素) ---
        const apiKeyInput = document.getElementById('apiKey');
        const apiEndpointInput = document.getElementById('apiEndpoint');
        const modelNameInput = document.getElementById('modelName');
        const temperatureInput = document.getElementById('temperature');
        const maxOutputTokensInput = document.getElementById('maxOutputTokens');
        const successSoundPathInput = document.getElementById('successSoundPath');
        const failureSoundPathInput = document.getElementById('failureSoundPath');
        const preNovelTextInput = document.getElementById('preNovelText');
        const novelTextInput = document.getElementById('novelText');
        const postNovelTextInput = document.getElementById('postNovelText');
        const structuredNovelTextarea = document.getElementById('structuredNovelText'); // 格式化文本区域
        const outputKsTextarea = document.getElementById('outputKs');                  // KAG输出区域
        const preprocessButton = document.getElementById('preprocessButton');           // 步骤一按钮
        const convertToKagButton = document.getElementById('convertToKagButton');       // 步骤二按钮
        const savePreprocessedButton = document.getElementById('savePreprocessedButton'); // 新增：保存按钮
        const step1StatusSpan = document.getElementById('step1Status');                 // 步骤一状态
        const step2StatusSpan = document.getElementById('step2Status');                 // 步骤二状态
        const saveParamsButton = document.getElementById('saveParamsButton');           // 保存参数按钮
        const loadParamsButton = document.getElementById('loadParamsButton');           // 加载参数按钮
        const paramStatusSpan = document.getElementById('param-status');                // 参数状态

        // --- 默认参数 (如果需要) ---
        // const DEFAULT_TEMPERATURE = 0.6;
        // const DEFAULT_MAX_OUTPUT_TOKENS = 8192;

        // --- SSE (Server-Sent Events) 解析器 ---
        let sseBuffer = ''; // 用于缓存不完整的 SSE 消息块
        function parseSSE(chunk) {
            const messages = []; // 存储解析出的完整消息
            sseBuffer += chunk; // 将新数据块追加到缓冲区
            const parts = sseBuffer.split('\n\n'); // 按双换行符分割消息块
            sseBuffer = parts.pop() || ''; // 保留最后一个可能不完整的块到缓冲区，其余处理
            for (const part of parts) {
                if (!part.trim()) continue; // 跳过空块
                const lines = part.split('\n'); // 按行分割单个消息
                let eventData = ''; // 消息数据
                let eventType = 'message'; // 消息类型，默认为 message
                for (const line of lines) {
                    if (line.startsWith('event:')) { // 解析事件类型
                        eventType = line.substring(6).trim();
                    } else if (line.startsWith('data:')) { // 解析数据行
                        eventData += line.substring(5).trim() + '\n'; // 累加数据，保留换行（如果原始数据有多行）
                    }
                }
                eventData = eventData.trim(); // 去除末尾换行符
                if (eventData) { // 如果数据不为空
                    try {
                        const jsonData = JSON.parse(eventData); // 尝试解析为 JSON
                        messages.push({ type: eventType, data: jsonData });
                    } catch (e) {
                        console.error("解析 SSE JSON 数据失败:", eventData, e);
                        // 如果解析失败，也推送一个错误消息，方便调试
                        messages.push({ type: 'error', data: { message: "接收到无效的 JSON 数据: " + eventData.substring(0, 50) + "..." } });
                    }
                }
            }
            return messages; // 返回解析出的消息数组
        }

        // --- 显示浏览器通知 ---
        function showNotification(title, body) {
            if (!("Notification" in window)) { // 检查浏览器是否支持 Notification API
                console.warn("浏览器不支持通知 API");
                return;
            }
            // 检查通知权限状态
            if (Notification.permission === "granted") { // 已授权
                new Notification(title, { body: body, icon: '/favicon.ico' }); // 直接创建通知 (可选：添加图标)
            } else if (Notification.permission !== "denied") { // 未授权且未拒绝
                Notification.requestPermission().then((permission) => { // 请求权限
                    if (permission === "granted") { // 用户同意授权
                        new Notification(title, { body: body, icon: '/favicon.ico' });
                    } else { // 用户拒绝授权
                        console.log("用户拒绝了通知权限");
                    }
                });
            }
            // 如果权限是 "denied"，则什么也不做
        }

        // --- 触发后端播放声音 ---
        async function triggerSoundPlayback(isSuccess) {
            const status = isSuccess ? "success" : "failure"; // 根据成功/失败决定状态
            console.log(`请求服务器播放 ${status} 声音.`);
            try {
                const response = await fetch('/play_sound', { // 调用后端 /play_sound 接口
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ status: status }) // 发送状态
                });
                 if (!response.ok) { // 检查响应状态 (包括 202 Accepted)
                     let errorMsg = `播放声音请求失败 (${response.status})`;
                     try { // 尝试解析后端返回的错误信息
                         const errorJson = await response.json();
                         errorMsg += `: ${errorJson.error || errorJson.message || '未知错误'}`;
                     } catch(e) { /* 忽略解析错误 */ }
                     console.error(errorMsg);
                 } else {
                     // 可选：处理后端返回的消息 (例如 "未配置路径")
                     const result = await response.json();
                     console.log("播放声音响应:", result.message);
                 }
            } catch (error) {
                console.error("调用 /play_sound 失败:", error);
            }
        }


        // --- 通用流式处理函数 (修改以更新按钮状态和触发通知/声音) ---
        async function processStream(targetTextarea, statusSpan, endpoint, payload, onCompleteCallback = null) {
            // --- 初始化 ---
            targetTextarea.value = '';                  // 清空目标文本区域
            statusSpan.textContent = '正在初始化...'; // 设置初始状态
            statusSpan.className = 'status-indicator'; // 重置状态样式
            sseBuffer = '';                             // 清空 SSE 缓冲区

            // --- 禁用所有操作按钮 ---
            preprocessButton.disabled = true;
            convertToKagButton.disabled = true;
            savePreprocessedButton.disabled = true; // 初始禁用保存按钮

            let finalStatus = "unknown"; // 跟踪最终状态: "success", "error"

            try {
                // --- 发送请求 ---
                statusSpan.textContent = '发送请求...';
                const response = await fetch(endpoint, { // 调用后端 API
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // --- 检查响应状态 ---
                if (!response.ok) { // 如果 HTTP 状态码不是 2xx
                    let errorMsg = `后端错误 (${response.status})`;
                    try { // 尝试解析 JSON 错误体
                        const errorJson = await response.json();
                        errorMsg += `: ${errorJson.error || '未知'}`;
                    } catch (e) { // 如果不是 JSON 错误体，使用状态文本
                        errorMsg += `: ${response.statusText}`;
                    }
                    throw new Error(errorMsg); // 抛出错误，中断执行
                }
                if (!response.body) throw new Error('响应体为空'); // 确保有响应体

                // --- 读取和处理流式数据 ---
                statusSpan.textContent = '接收数据...';
                const reader = response.body.getReader(); // 获取流读取器
                const decoder = new TextDecoder("utf-8"); // 创建解码器
                finalStatus = "success"; // 假设成功，除非发生错误

                while (true) { // 持续读取流
                    const { value, done } = await reader.read(); // 读取一块数据
                    if (done) { // 如果流结束
                        statusSpan.textContent = '处理完成!';
                        if (onCompleteCallback) onCompleteCallback(); // 调用完成回调
                        break; // 退出循环
                    }

                    // --- 解码和解析 SSE ---
                    const decodedChunk = decoder.decode(value, { stream: true }); // 解码数据块
                    const messages = parseSSE(decodedChunk); // 解析 SSE 消息
                    if (messages.length > 0) { console.log("前端接收到 SSE 消息:", messages); } // 调试输出

                    // --- 处理解析出的消息 ---
                    for (const message of messages) {
                        if (message.type === 'error' || (message.data && message.data.type === 'error')) { // 错误消息
                            const errorText = message.data.message || message.data.raw || "未知流错误";
                            console.error("流错误:", errorText);
                            statusSpan.textContent = `错误: ${errorText}`;
                            statusSpan.className = 'status-indicator error'; // 设置错误样式
                            finalStatus = "error"; // 标记为失败
                            await reader.cancel(); // 取消读取流
                            return; // 提前退出函数
                        }
                        else if (message.data && message.data.type === 'chunk') { // 文本块消息
                            targetTextarea.value += message.data.content; // 追加到文本区域
                        }
                        else if (message.data && (message.data.type === 'header' || message.data.type === 'footer')) { // 页眉/页脚消息
                            targetTextarea.value += message.data.content; // 追加到文本区域
                        }
                        else if (message.type === 'warning' || (message.data && message.data.type === 'warning')) { // 警告消息
                            const warnText = message.data.message || "未知警告";
                            console.warn("流警告:", warnText);
                            // 可以选择性地显示警告，但目前只在控制台打印
                        }
                        else { // 未知结构的消息
                            console.warn("接收到未知消息结构:", message);
                        }
                        targetTextarea.scrollTop = targetTextarea.scrollHeight; // 自动滚动到底部
                    }
                } // end while loop
            } catch (error) { // 捕获 fetch 或处理过程中的错误
                console.error(`流处理错误 (${endpoint}):`, error);
                statusSpan.textContent = `失败: ${error.message}`;
                statusSpan.className = 'status-indicator error'; // 设置错误样式
                finalStatus = "error"; // 标记为失败
            } finally { // 无论成功或失败，最终都会执行
                // --- 触发通知和声音 ---
                const isSuccess = finalStatus === "success";
                const stepName = endpoint === '/preprocess_stream' ? "步骤一 (格式化)" : "步骤二 (KAG转换)";

                if (isSuccess) {
                    showNotification(`${stepName} 完成`, "处理已成功结束。");
                    triggerSoundPlayback(true); // 播放成功声音
                } else {
                    showNotification(`${stepName} 失败`, `处理过程中发生错误: ${statusSpan.textContent}`);
                    triggerSoundPlayback(false); // 播放失败声音
                }

                // --- 更新按钮状态 ---
                preprocessButton.disabled = false; // 步骤一按钮总是可以重新启用

                // 步骤二按钮: 只有当“格式化文本”区域有内容时才启用
                convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';

                // 保存按钮: 只有当步骤一成功完成时才启用
                if (endpoint === '/preprocess_stream' && isSuccess) {
                    savePreprocessedButton.disabled = false;
                } else {
                    // 如果是步骤二完成，或者步骤一失败，禁用保存按钮
                    savePreprocessedButton.disabled = true;
                }

                // 如果是步骤二完成，并且格式化文本区仍然有内容，则步骤二按钮也应保持可用
                if (endpoint === '/convert_stream') {
                    convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';
                }
            }
        }


        // --- 保存参数 (包括声音路径) ---
        async function saveParameters() {
            paramStatusSpan.textContent = "正在保存参数到服务器..."; paramStatusSpan.style.color = "#669";
            const paramsToSave = {
                apiKey: apiKeyInput.value.trim(),
                apiEndpoint: apiEndpointInput.value.trim(),
                modelName: modelNameInput.value.trim(),
                temperature: temperatureInput.value ? parseFloat(temperatureInput.value) : null,
                maxOutputTokens: maxOutputTokensInput.value ? parseInt(maxOutputTokensInput.value, 10) : null,
                successSoundPath: successSoundPathInput.value.trim(), // 保存成功声音路径
                failureSoundPath: failureSoundPathInput.value.trim()  // 保存失败声音路径
            };
            try {
                const response = await fetch('/save_config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(paramsToSave) });
                const result = await response.json();
                if (response.ok) { paramStatusSpan.textContent = result.message || "参数已成功保存到服务器。"; paramStatusSpan.style.color = "green"; }
                else { throw new Error(result.error || `保存失败 (${response.status})`); }
            } catch (e) { console.error("保存参数失败:", e); paramStatusSpan.textContent = `保存参数失败: ${e.message}`; paramStatusSpan.style.color = "red"; }
            finally { setTimeout(() => { paramStatusSpan.textContent = ""; }, 4000); } // 4秒后清除状态消息
        }

        // --- 加载参数 (包括声音路径) ---
        async function loadParameters() {
            paramStatusSpan.textContent = "正在从服务器加载参数..."; paramStatusSpan.style.color = "#669";
            try {
                const response = await fetch('/load_config');
                const configData = await response.json();
                if (!response.ok) { throw new Error(configData.error || `加载失败 (${response.status})`); }
                let loaded = false; // 标记是否加载到有效数据
                if (configData && typeof configData === 'object') {
                    // 逐个加载配置项
                    if (configData.apiKey) { apiKeyInput.value = configData.apiKey; loaded = true; } else { apiKeyInput.value = ''; }
                    if (configData.apiEndpoint) { apiEndpointInput.value = configData.apiEndpoint; loaded = true; } else { apiEndpointInput.value = ''; }
                    if (configData.modelName) { modelNameInput.value = configData.modelName; loaded = true; } else { modelNameInput.value = ''; }
                    if (configData.temperature !== null && configData.temperature !== undefined) { temperatureInput.value = configData.temperature; loaded = true; } else { temperatureInput.value = ''; }
                    if (configData.maxOutputTokens !== null && configData.maxOutputTokens !== undefined) { maxOutputTokensInput.value = configData.maxOutputTokens; loaded = true; } else { maxOutputTokensInput.value = ''; }
                    if (configData.successSoundPath) { successSoundPathInput.value = configData.successSoundPath; loaded = true;} else { successSoundPathInput.value = '';}
                    if (configData.failureSoundPath) { failureSoundPathInput.value = configData.failureSoundPath; loaded = true;} else { failureSoundPathInput.value = '';}
                } else { // 如果加载的数据无效，清空所有字段
                     apiKeyInput.value = ''; apiEndpointInput.value = ''; modelNameInput.value = ''; temperatureInput.value = ''; maxOutputTokensInput.value = '';
                     successSoundPathInput.value = ''; failureSoundPathInput.value = '';
                }
                if (loaded) { paramStatusSpan.textContent = "已从服务器加载参数。"; paramStatusSpan.style.color = "blue"; }
                else { paramStatusSpan.textContent = "服务器上未找到或无有效参数。"; paramStatusSpan.style.color = "#666"; }

                // 新增：加载参数后，检查格式化文本框是否有内容，以决定是否启用步骤二按钮
                convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';

            } catch (e) { // 加载失败处理
                console.error("加载参数失败:", e); paramStatusSpan.textContent = `加载参数失败: ${e.message}`; paramStatusSpan.style.color = "red";
                 // 清空所有字段
                apiKeyInput.value = ''; apiEndpointInput.value = ''; modelNameInput.value = ''; temperatureInput.value = ''; maxOutputTokensInput.value = '';
                successSoundPathInput.value = ''; failureSoundPathInput.value = '';
                // 确保按钮状态正确
                convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';
            } finally {
                setTimeout(() => { paramStatusSpan.textContent = ""; }, 4000); // 4秒后清除状态消息
            }
        }

        // --- 新增：保存格式化后的文本到本地 TXT 文件 ---
        function savePreprocessedText() {
            const textToSave = structuredNovelTextarea.value; // 获取文本内容
            if (!textToSave.trim()) { // 如果内容为空，则不执行保存
                alert("没有可保存的内容。");
                return;
            }
            // 创建 Blob 对象
            const blob = new Blob([textToSave], { type: 'text/plain;charset=utf-8' });
            // 创建一个临时的 URL 指向 Blob 对象
            const url = URL.createObjectURL(blob);
            // 创建一个隐藏的 <a> 标签用于触发下载
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            // 设置建议的文件名
            a.download = 'preprocessed_novel.txt';
            // 将 <a> 标签添加到文档中
            document.body.appendChild(a);
            // 模拟点击 <a> 标签
            a.click();
            // 清理：从文档中移除 <a> 标签并释放 URL 对象
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // --- 页面加载时执行的操作 ---
        document.addEventListener('DOMContentLoaded', () => {
             // 尝试请求通知权限 (如果尚未授予或拒绝)
             if ("Notification" in window && Notification.permission !== "granted" && Notification.permission !== "denied") {
                 Notification.requestPermission().then(permission => {
                     console.log("通知权限状态:", permission);
                 });
             }
             loadParameters(); // 自动加载保存的参数

             // 新增：监听格式化文本区域的输入事件，动态更新步骤二按钮状态
             structuredNovelTextarea.addEventListener('input', () => {
                 convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';
                 // 当用户编辑时，如果步骤一未完成，则禁用保存按钮
                 // (如果步骤一已完成，保存按钮会被启用，这里不应再禁用它，除非文本被清空)
                 if (structuredNovelTextarea.value.trim() === '') {
                     savePreprocessedButton.disabled = true;
                 } else {
                    // 如果是通过步骤一生成的文本，保存按钮应保持启用状态
                    // 如果是手动粘贴的，保存按钮保持禁用状态 (除非用户想手动保存，那逻辑可以调整)
                    // 当前逻辑：只有步骤一成功才启用保存按钮，手动编辑不启用。
                 }
             });
         });

        // --- 按钮事件监听器 ---
        saveParamsButton.addEventListener('click', saveParameters);     // 保存参数按钮
        loadParamsButton.addEventListener('click', loadParameters);     // 加载参数按钮
        savePreprocessedButton.addEventListener('click', savePreprocessedText); // 新增：保存预处理文本按钮

        // --- 步骤一：转换小说格式按钮点击事件 ---
        preprocessButton.addEventListener('click', async () => {
            // --- 准备阶段 ---
            preprocessButton.disabled = true;           // 禁用自己
            convertToKagButton.disabled = true;         // 禁用步骤二按钮
            savePreprocessedButton.disabled = true;    // 禁用保存按钮
            step1StatusSpan.textContent = '';           // 清空步骤一状态
            step1StatusSpan.className = 'status-indicator';
            step2StatusSpan.textContent = '';           // 清空步骤二状态
            step2StatusSpan.className = 'status-indicator';
            structuredNovelTextarea.value = '';         // 清空步骤一输出区域
            outputKsTextarea.value = '';                // 清空步骤二输出区域

            // --- 获取输入参数 ---
            const apiKey = apiKeyInput.value.trim();
            const apiBaseUrl = apiEndpointInput.value.trim().replace(/\/+$/, ''); // 移除末尾斜杠
            const modelName = modelNameInput.value.trim();
            let temperature = parseFloat(temperatureInput.value);
            if (isNaN(temperature) || temperature < 0 || temperature > 2) temperature = null; // 验证 Temperature
            let maxOutputTokens = parseInt(maxOutputTokensInput.value, 10);
            if (isNaN(maxOutputTokens) || maxOutputTokens < 1) maxOutputTokens = null; // 验证 Max Tokens
            const novelText = novelTextInput.value.trim();
            const preNovelText = preNovelTextInput.value.trim();
            const postNovelText = postNovelTextInput.value.trim();

            // --- 输入验证 ---
            if (!apiKey || !apiBaseUrl || !modelName || !novelText) {
                step1StatusSpan.textContent = '错误：API 配置和原始小说原文不能为空！';
                step1StatusSpan.className = 'status-indicator error';
                preprocessButton.disabled = false; // 重新启用步骤一按钮
                // 其他按钮保持禁用状态
                return; // 提前退出
            }

            // --- 构建请求负载 ---
            const payload = {
                api_base_url: apiBaseUrl,
                model_name: modelName,
                api_key: apiKey,
                temperature: temperature,
                max_output_tokens: maxOutputTokens,
                pre_novel_text: preNovelText,
                novel_text: novelText,
                post_novel_text: postNovelText
            };

            // --- 调用流式处理函数 ---
            // onCompleteCallback 在 processStream 的 finally 块中被隐式处理（通过更新按钮状态）
            await processStream( structuredNovelTextarea, step1StatusSpan, '/preprocess_stream', payload, null );
        });

        // --- 步骤二：格式转 KAG 按钮点击事件 ---
        convertToKagButton.addEventListener('click', async () => {
            // --- 准备阶段 ---
            convertToKagButton.disabled = true;         // 禁用自己
            preprocessButton.disabled = true;           // 禁用步骤一按钮
            // 保存按钮的状态不在此处改变，由步骤一结果决定
            step2StatusSpan.textContent = '';           // 清空步骤二状态
            step2StatusSpan.className = 'status-indicator';
            outputKsTextarea.value = '';                // 清空步骤二输出区域

            // --- 获取输入参数 ---
            const apiKey = apiKeyInput.value.trim();
            const apiBaseUrl = apiEndpointInput.value.trim().replace(/\/+$/, '');
            const modelName = modelNameInput.value.trim();
            let temperature = parseFloat(temperatureInput.value);
            if (isNaN(temperature) || temperature < 0 || temperature > 2) temperature = null;
            let maxOutputTokens = parseInt(maxOutputTokensInput.value, 10);
            if (isNaN(maxOutputTokens) || maxOutputTokens < 1) maxOutputTokens = null;
            const structuredText = structuredNovelTextarea.value.trim(); // 从格式化文本区域获取输入

            // --- 输入验证 ---
            if (!apiKey || !apiBaseUrl || !modelName || !structuredText) {
                step2StatusSpan.textContent = '错误：API 配置和格式化文本不能为空！';
                step2StatusSpan.className = 'status-indicator error';
                // 只重新启用步骤二按钮（如果格式化文本区仍有内容）
                convertToKagButton.disabled = structuredNovelTextarea.value.trim() === '';
                preprocessButton.disabled = false; // 步骤一按钮也重新启用
                return; // 提前退出
            }

            // --- 构建请求负载 ---
            const payload = {
                api_base_url: apiBaseUrl,
                model_name: modelName,
                api_key: apiKey,
                temperature: temperature,
                max_output_tokens: maxOutputTokens,
                structured_text: structuredText
            };

            // --- 调用流式处理函数 ---
            await processStream( outputKsTextarea, step2StatusSpan, '/convert_stream', payload, null );
        });

    </script>
</body>
</html>